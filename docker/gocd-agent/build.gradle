/*
 * Copyright Thoughtworks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import com.thoughtworks.go.build.docker.BuildDockerImageTask
import com.thoughtworks.go.build.docker.Distro
import com.thoughtworks.go.build.docker.DistroVersion
import com.thoughtworks.go.build.docker.ImageType
import groovy.json.JsonOutput
import io.github.resilience4j.retry.Retry
import io.github.resilience4j.retry.RetryConfig

import java.time.Duration

buildscript {
  dependencies {
    classpath project.deps.resilience4jRetry
  }
}

plugins {
  id 'base'
}

def dockerTasks = Distro.values()
  .collectMany {distro -> distro.supportedVersions.collect { v -> [distro, v] as Tuple2<Distro, DistroVersion> } }
  .collect { target ->

  def (distro, distroVersion) = target

  tasks.register("docker-${distro.taskSuffix(distroVersion)}", BuildDockerImageTask.class) { BuildDockerImageTask task ->
    task.configureFor(ImageType.agent)
    task.distro = distro
    task.distroVersion = distroVersion
    task.tiniVersion = project.versions.tini
    task.outputDir = layout.buildDirectory.dir("docker")

    def licenseSourceFile = rootProject.file("LICENSE")

    task.templateHelper = {
      deleteGitRepoDirectoryContents()

      fileOps.copy {
        from licenseSourceFile
        into gitRepoDirectory
      }

      task.writeTemplateToFile("README.md.ftl", "README.md")

      [
        'agent-bootstrapper-logback-include.xml',
        'agent-launcher-logback-include.xml',
        'agent-logback-include.xml',
      ].forEach { eachFile ->
        task.resolveGitRepoFileFor(eachFile).bytes = BuildDockerImageTask.class.getResource("/gocd-docker-agent/${eachFile}").bytes
      }

      [
        'docker-entrypoint.sh',
      ].forEach { eachFile ->
        def file = task.resolveGitRepoFileFor(eachFile)
        file.bytes = BuildDockerImageTask.class.getResource("/gocd-docker-agent/${eachFile}").bytes
        file.setExecutable(true, false)
      }

      if (distro == Distro.docker) {
        def file = task.resolveGitRepoFileFor("run-docker-daemon.sh")
        file.bytes = BuildDockerImageTask.class.getResource("/gocd-docker-agent/run-docker-daemon.sh").bytes
        file.setExecutable(true, false)

        file = task.resolveGitRepoFileFor("dockerd-sudo")
        file.bytes = BuildDockerImageTask.class.getResource("/gocd-docker-agent/dockerd-sudo").bytes
      }
    }

    // test image
    task.verifyHelper = {
      def cleanContainer = { OutputStream errorStreamOverride ->
        execOps.exec {
          commandLine = ["docker", "rm", "--force", "--volumes", task.dockerImageName]
          standardOutput = OutputStream.nullOutputStream()
          if (errorStreamOverride) errorOutput = errorStreamOverride
        }
      }

      cleanContainer.call(OutputStream.nullOutputStream()) // Clean-up after any previous aborted runs

      // daemonize the container
      execOps.exec {
        def additionalFlags = distro == Distro.docker ? ["--privileged"] : []
        commandLine = ["docker", "run", "-e", "GO_SERVER_URL=http://localhost:8153/go", "-d", "--name", task.dockerImageName] + additionalFlags + [task.imageNameWithTag] as List<String>
      }

      def start = System.currentTimeMillis()
      try {
        Retry.of("wait-for-container-to-start",
          RetryConfig.custom().maxAttempts(60).waitDuration(Duration.ofMillis(500)).failAfterMaxAttempts(true).build()
        ).executeRunnable {
          task.verifyProcessInContainerStarted(
            "lib/agent-bootstrapper.jar -serverUrl http://localhost:8153/go",
            /Connect to localhost:8153.*Connection refused/
          )
        }

        distro.additionalVerifyCommands.each { command ->
          execOps.exec {
            commandLine = ["docker", "exec", task.dockerImageName] + command
            errorOutput = standardOutput // Docker is noisy on STDERR when pulling images via these exec commands
          }
        }
      } finally {
        logger.lifecycle("Took ${System.currentTimeMillis() - start} ms to verify [${task.dockerImageName}] container started.")
        // remove the container
        cleanContainer.call()
      }
    }
  }
}

tasks.register('generateManifest') {
  def manifest = layout.buildDirectory.file("docker/manifest.json")
  outputs.file(manifest)

  doLast {
    def meta = []
    dockerTasks.collect { it.get() }.each { dockerTask ->
      meta << [
        file     : "${dockerTask.imageTarFile.name}",
        format   : 'oci',
        imageName: dockerTask.dockerImageName,
        tag      : dockerTask.imageTag,
        platforms: dockerTask.supportedPlatforms
      ]
    }

    def jsonFile = manifest.get().asFile
    jsonFile.parentFile.mkdirs()
    jsonFile.withWriter("utf-8") { Writer out ->
      out << JsonOutput.toJson(meta)
    }
  }
}

assemble {
  dependsOn(dockerTasks)
  dependsOn(generateManifest)
}
